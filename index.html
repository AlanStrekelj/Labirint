<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <title>Labirint</title>
	<link rel="icon" href="labirint.svg" type="image/svg+xml">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&family=Roboto+Mono:wght@500&display=swap');

        body {
            background-color: #0b1118; 
            background-image: radial-gradient(circle at 50% 0%, #1c2636 0%, #0b1118 80%);
            color: #e3e3e3;
            font-family: 'Google Sans', 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 20px;
            padding-bottom: 40px;
            min-height: 100vh;
            height: auto;
            overflow-y: auto;
            margin: 0;
            box-sizing: border-box;
            user-select: none;
        }

        /* --- NAVODILA (SIDEBAR) --- */
        .instructions-panel {
            position: fixed;
            right: 40px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            width: 220px;
            z-index: 5;
            box-shadow: 0 15px 35px rgba(0,0,0,0.4);
            transition: opacity 0.3s;
        }

        .instructions-panel h3 {
            margin: 0 0 20px 0;
            color: #4facfe;
            font-size: 1.1rem;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }

        .instruction-item {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
            font-size: 0.9rem;
            color: #b0c4de;
        }

        .instruction-item:last-child { margin-bottom: 0; }

        .key-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
            color: #ffd700;
        }

        .action-text {
            font-weight: 700;
            color: #e3e3e3;
            margin-bottom: 2px;
        }

        @media (max-width: 1300px) {
            .instructions-panel {
                display: none;
            }
        }

        /* --- HUD --- */
        .hud-container {
            display: flex;
            gap: 40px;
            margin-bottom: 15px;
            z-index: 2;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 30px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            flex-shrink: 0;
        }

        .hud-item { text-align: center; }
        .hud-label { font-size: 0.8rem; text-transform: uppercase; color: #8da2b5; margin-bottom: 2px;}
        .hud-value { font-family: 'Roboto Mono', monospace; font-size: 1.8rem; font-weight: 500; color: #4facfe; text-shadow: 0 0 15px rgba(79, 172, 254, 0.4); }
        .hud-value.best { color: #ffd700; text-shadow: 0 0 15px rgba(255, 215, 0, 0.4); }

        .maze-container {
            position: relative;
            width: 650px; 
            height: 650px;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1500px;
            transition: width 0.4s ease, height 0.4s ease;
            margin: 10px 0;
            flex-shrink: 0;
        }

        .background-name {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: 700;
            color: #1f293a; 
            text-align: center;
            width: 100%;
            z-index: 0;
            pointer-events: none;
            transition: all 0.5s ease;
        }

        .maze-container.active .background-name {
            color: #4facfe;
            opacity: 0.5; 
            text-shadow: 0 0 50px rgba(79, 172, 254, 0.8);
            transform: translate(-50%, -50%) scale(1.1);
        }

        canvas {
            position: relative;
            z-index: 1;
            border-radius: 12px;
            border: 2px solid #2d3b4f;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            cursor: grab;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d;
        }
        canvas:active { cursor: grabbing; border-color: #4facfe; }

        /* --- KONTROLE --- */
        .controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            z-index: 2;
            align-items: center;
            max-width: 900px;
            flex-shrink: 0;
        }

        .control-element {
            height: 48px; 
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            font-family: 'Google Sans', sans-serif;
            font-size: 15px;
            font-weight: 500;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s, background 0.3s;
        }

        select.control-element {
            padding: 0 40px 0 20px;
            border: none;
            background-color: #2d3b4f;
            color: white;
            cursor: pointer;
            outline: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 15px center;
            background-size: 12px;
        }

        .toggle-container {
            background: #2d3b4f;
            padding: 0 20px;
            cursor: pointer;
            color: #e3e3e3;
            gap: 10px;
            border: 1px solid transparent; 
        }
        .toggle-container:hover { background: #3a4b63; transform: translateY(-2px); }
        .toggle-container input { cursor: pointer; accent-color: #4facfe; width: 16px; height: 16px; }

        button.control-element {
            padding: 0 24px;
            cursor: pointer;
            border: none;
            color: white;
        }
        button:hover { transform: translateY(-2px); }
        button:active { transform: translateY(1px); }

        button.solve { background: linear-gradient(135deg, #306de6, #9b59b6); min-width: 140px; }
        button.solve.active { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        button.reset { background: linear-gradient(135deg, #ff7e5f, #feb47b); color: #3e1f15; }

        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(19, 27, 38, 0.95);
            padding: 30px 50px;
            border-radius: 20px;
            border: 1px solid #4facfe;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s ease;
            z-index: 100;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        #message.show { opacity: 1; transform: translate(-50%, -50%) scale(1); pointer-events: auto; }
        #message h2 { margin: 0 0 10px 0; color: #4facfe; font-size: 2rem; }
        #finalTimeDisplay { font-size: 1.2rem; margin-bottom: 20px; color: #fff; }
    </style>
</head>
<body>

    <div class="instructions-panel">
        <h3>Navodila</h3>
        <div class="instruction-item">
            <span class="key-icon">üñ±Ô∏è L</span>
            <span class="action-text">Levi klik</span>
            <span>Vrti v smeri ure</span>
        </div>
        <div class="instruction-item">
            <span class="key-icon">üñ±Ô∏è D</span>
            <span class="action-text">Desni klik</span>
            <span>Vrti proti smeri ure</span>
        </div>
        <div class="instruction-item">
            <span class="key-icon">üñ±Ô∏è O</span>
            <span class="action-text">Kole≈°ƒçek</span>
            <span>Ponastavi pogled</span>
        </div>
    </div>

    <div class="hud-container">
        <div class="hud-item">
            <div class="hud-label">ƒåas</div>
            <div class="hud-value" id="timerDisplay">00:00</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Rekord</div>
            <div class="hud-value best" id="bestTimeDisplay">--:--</div>
        </div>
    </div>
    
    <div class="maze-container" id="mazeContainer">
        <div class="background-name">Alan ≈†trekelj</div>
        <canvas id="mazeCanvas" width="650" height="650"></canvas>
    </div>
    
    <div class="controls">
        <select id="difficultySelect" class="control-element" onchange="changeDifficulty()">
            <option value="15">Lahko (15x15)</option>
            <option value="25" selected>Srednje (25x25)</option>
            <option value="40">Te≈æko (40x40)</option>
        </select>

        <label class="control-element toggle-container" title="Temni naƒçin z omejenim vidom">
            <input type="checkbox" id="flashlightToggle" onchange="toggleFlashlight()">
            <span class="toggle-label">üåë Tema</span>
        </label>

        <label class="control-element toggle-container" title="Zvoƒçni uƒçinki">
            <input type="checkbox" id="soundToggle">
            <span class="toggle-label">üîä Zvok</span>
        </label>

        <button class="control-element reset" onclick="flipAndReset()">‚ú® Nov Labirint</button>
        <button id="solveBtn" class="control-element solve" onclick="toggleSolve()">Poka≈æi re≈°itev ü§ñ</button>
    </div>

    <div id="message">
        <h2 id="winTitle">ƒåestitke! üöÄ</h2>
        <div id="finalTimeDisplay">Tvoj ƒças: 12.5s</div>
        <button class="control-element reset" onclick="closeMessage()">Igraj ponovno</button>
    </div>

<script>
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    const messageBox = document.getElementById('message');
    const mazeContainer = document.getElementById('mazeContainer');
    const solveBtn = document.getElementById('solveBtn');
    
    const timerDisplay = document.getElementById('timerDisplay');
    const bestTimeDisplay = document.getElementById('bestTimeDisplay');
    const finalTimeDisplay = document.getElementById('finalTimeDisplay');
    const winTitle = document.getElementById('winTitle');

    // --- AUDIO CONTEXT (Zvok) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = new AudioContext();

    function playSound(type) {
        if (!document.getElementById('soundToggle').checked) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();

        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        if (type === 'move') {
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'wall') {
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(100, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); 
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'win') {
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
            oscillator.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.2);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.5);
        }
    }

    // --- SPREMENLJIVKE ZA VRTENJE ---
    let zRotationAngle = 0;
    let flipAngle = 0;
    let flipAxis = { x: 0, y: 1 }; 
    let isRotating = false;
    let rotationSpeed = 0; 
    let rotationFrame;

    function updateTransform() {
        canvas.style.transform = `rotate3d(${flipAxis.x}, ${flipAxis.y}, 0, ${flipAngle}deg) rotateZ(${zRotationAngle}deg)`;
    }

    function changeDifficulty() {
        const select = document.getElementById('difficultySelect');
        const val = parseInt(select.value);
        select.blur(); 
        
        let newSize = 550; 
        if (val === 25) newSize = 650; 
        if (val === 40) newSize = 750; 

        cols = val;
        rows = val;

        flipAndReset(newSize);
    }

    function toggleFlashlight() {
        draw(); 
        document.getElementById('flashlightToggle').blur();
    }

    function flipAndReset(targetSize) {
        const dirX = Math.random() < 0.5 ? 1 : -1;
        const dirY = Math.random() < 0.5 ? 1 : -1;
        
        canvas.style.transition = 'none';
        flipAngle = 0;
        flipAxis = { x: dirX, y: dirY };
        updateTransform();
        canvas.offsetHeight; 
        canvas.style.transition = 'transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
        
        flipAngle = 360; 
        updateTransform();

        setTimeout(() => {
            if (targetSize) {
                canvas.width = targetSize;
                canvas.height = targetSize;
                mazeContainer.style.width = targetSize + 'px';
                mazeContainer.style.height = targetSize + 'px';
                size = canvas.width / cols;
            }
            initMaze();
        }, 400); 
    }

    // --- POPRAVEK: GLOBALNO PREPREƒåEVANJE AUTO-SCROLLA ---
    window.addEventListener('mousedown', function(e) {
        // ƒåe je pritisnjen sredinski gumb (kole≈°ƒçek - gumb 1), prepreƒçi privzeto obna≈°anje (pu≈°ƒçico)
        if(e.button === 1) {
            e.preventDefault();
        }
    }, { passive: false });

    canvas.addEventListener('contextmenu', e => e.preventDefault());
    canvas.addEventListener('mousedown', e => {
        if (e.button === 1) e.preventDefault(); // Prepreƒçi scroll tudi tukaj za vsak sluƒçaj
        
        if (e.button === 0) startRotation(2); 
        else if (e.button === 2) startRotation(-2); 
        else if (e.button === 1) { stopRotation(); zRotationAngle = 0; updateTransform(); }
    });
    canvas.addEventListener('mouseup', () => stopRotation());
    canvas.addEventListener('mouseleave', stopRotation);

    function startRotation(speed) {
        if (!isRotating) {
            isRotating = true;
            rotationSpeed = speed;
            mazeContainer.classList.add('active'); 
            canvas.style.transition = 'transform 0.1s linear'; 
            rotationLoop();
        }
    }

    function stopRotation() {
        isRotating = false;
        mazeContainer.classList.remove('active');
        canvas.style.transition = 'transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
        cancelAnimationFrame(rotationFrame);
    }

    function rotationLoop() {
        if (isRotating) {
            zRotationAngle += rotationSpeed; 
            updateTransform(); 
            rotationFrame = requestAnimationFrame(rotationLoop);
        }
    }

    // --- LOGIKA IGRE ---
    let cols = 25; 
    let rows = 25;
    let size = canvas.width / cols; 

    let grid = [];
    let stack = [];
    let player = { x: 0, y: 0 };
    let goal = { x: 0, y: 0 }; 
    let solutionPath = []; 
    let mistakeCells = []; 
    let current; 
    let isGenerating = false;
    let isSolutionShown = false; 
    let solutionAnimationTimeout; 
    let solutionUsed = false;

    // ƒåAS
    let startTime = 0;
    let timerInterval = null;
    let gameStarted = false; 

    const COLORS = {
        wall: '#4a5b75',        
        solution: 'rgba(79, 172, 254, 0.2)', 
        mistake: 'rgba(231, 76, 60, 0.3)', 
        player: '#4facfe', 
        goal: '#ffd700'    
    };

    class Cell {
        constructor(c, r) {
            this.c = c;
            this.r = r;
            this.walls = [true, true, true, true]; 
            this.visited = false;
        }

        show() {
            let x = this.c * size;
            let y = this.r * size;
            let cx = x + size/2; 
            let cy = y + size/2; 

            if (!this.visited) return;

            ctx.strokeStyle = COLORS.wall;
            ctx.lineWidth = size < 15 ? 1 : 1.5; 
            ctx.lineCap = "round"; 

            ctx.beginPath();
            if (this.walls[0]) { ctx.moveTo(x, y); ctx.lineTo(x + size, y); }
            if (this.walls[1]) { ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); }
            if (this.walls[2]) { ctx.moveTo(x + size, y + size); ctx.lineTo(x, y + size); }
            if (this.walls[3]) { ctx.moveTo(x, y + size); ctx.lineTo(x, y); }
            ctx.stroke();
            
            if (solutionPath.includes(this)) {
                ctx.fillStyle = COLORS.solution;
                ctx.fillRect(x, y, size, size);
                
                ctx.font = `${size * 0.6}px Arial`;
                ctx.fillStyle = "rgba(79, 172, 254, 0.8)";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("üë£", cx, cy);
            }

            if (mistakeCells.includes(this)) {
                ctx.fillStyle = COLORS.mistake;
                ctx.fillRect(x, y, size, size);
                
                ctx.font = `${size * 0.7}px Arial`;
                ctx.fillStyle = "rgba(231, 76, 60, 1)";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("‚ùå", cx, cy);
            }
        }

        checkNeighbors() {
            let neighbors = [];
            let top = grid[index(this.c, this.r - 1)];
            let right = grid[index(this.c + 1, this.r)];
            let bottom = grid[index(this.c, this.r + 1)];
            let left = grid[index(this.c - 1, this.r)];

            if (top && !top.visited) neighbors.push(top);
            if (right && !right.visited) neighbors.push(right);
            if (bottom && !bottom.visited) neighbors.push(bottom);
            if (left && !left.visited) neighbors.push(left);

            if (neighbors.length > 0) {
                let r = Math.floor(Math.random() * neighbors.length);
                return neighbors[r];
            } else return undefined;
        }
    }

    function index(c, r) {
        if (c < 0 || r < 0 || c > cols - 1 || r > rows - 1) return -1;
        return c + r * cols;
    }

    function resetTimer() {
        stopTimer();
        gameStarted = false;
        timerDisplay.innerText = "00:00";
        updateBestTimeDisplay();
    }

    function startTimer() {
        if (gameStarted || solutionUsed) return;
        gameStarted = true;
        startTime = Date.now();
        timerInterval = setInterval(() => {
            let elapsed = Date.now() - startTime;
            timerDisplay.innerText = formatTime(elapsed);
        }, 100);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }

    function formatTime(ms) {
        let totalSeconds = Math.floor(ms / 1000);
        let minutes = Math.floor(totalSeconds / 60);
        let seconds = totalSeconds % 60;
        return `${pad(minutes)}:${pad(seconds)}`;
    }

    function pad(num) { return num < 10 ? '0' + num : num; }

    function getStorageKey() { return `maze_best_${cols}`; }

    function updateBestTimeDisplay() {
        const key = getStorageKey();
        const best = localStorage.getItem(key);
        bestTimeDisplay.innerText = best ? formatTime(best) : "--:--";
    }

    function checkHighScore(finalMs) {
        const key = getStorageKey();
        const currentBest = localStorage.getItem(key);
        
        if (!currentBest || finalMs < parseInt(currentBest)) {
            localStorage.setItem(key, finalMs);
            winTitle.innerText = "NOV REKORD! üèÜ";
            winTitle.style.color = "#ffd700";
            updateBestTimeDisplay();
        } else {
            winTitle.innerText = "ƒåestitke! üöÄ";
            winTitle.style.color = "#4facfe";
        }
    }

    function initMaze() {
        closeMessage(); 
        grid = [];
        stack = [];
        solutionPath = [];
        mistakeCells = []; 
        player = { x: 0, y: 0 };
        goal = { x: cols - 1, y: rows - 1 };
        
        isGenerating = true;
        isSolutionShown = false;
        solutionUsed = false;
        clearTimeout(solutionAnimationTimeout);
        solveBtn.innerText = "Poka≈æi re≈°itev ü§ñ";
        solveBtn.classList.remove('active');

        resetTimer(); 

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                grid.push(new Cell(c, r));
            }
        }

        current = grid[0];
        current.visited = true;
        animateGeneration();
    }

    function animateGeneration() {
        const stepsPerFrame = cols > 30 ? 200 : 60; 

        for (let i = 0; i < stepsPerFrame; i++) {
            let next = current.checkNeighbors();
            if (next) {
                next.visited = true;
                stack.push(current);
                removeWalls(current, next);
                current = next;
            } else if (stack.length > 0) {
                current = stack.pop();
            } else {
                isGenerating = false;
                draw(); 
                return; 
            }
        }
        draw(); 
        if (isGenerating) requestAnimationFrame(animateGeneration);
    }

    function removeWalls(a, b) {
        let x = a.c - b.c;
        if (x === 1) { a.walls[3] = false; b.walls[1] = false; }
        if (x === -1) { a.walls[1] = false; b.walls[3] = false; }
        let y = a.r - b.r;
        if (y === 1) { a.walls[0] = false; b.walls[2] = false; }
        if (y === -1) { a.walls[2] = false; b.walls[0] = false; }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.beginPath();
        for (let i = 0; i < grid.length; i++) {
            grid[i].show();
        }

        if (isGenerating) return;

        let cx = goal.x * size + size/2;
        let cy = goal.y * size + size/2;
        ctx.shadowBlur = 20;
        ctx.shadowColor = COLORS.goal;
        ctx.font = `${size * 0.8}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üöÄ", cx, cy);
        ctx.shadowBlur = 0; 

        let px = player.x * size + size/2;
        let py = player.y * size + size/2;
        ctx.shadowBlur = 20;
        ctx.shadowColor = COLORS.player;
        ctx.font = `${size * 0.8}px Arial`;
        ctx.fillText("ü§ñ", px, py);
        ctx.shadowBlur = 0;

        if (document.getElementById('flashlightToggle').checked) {
            ctx.globalCompositeOperation = 'source-over';
            
            let grd = ctx.createRadialGradient(px, py, size * 1.5, px, py, size * 5);
            grd.addColorStop(0, "rgba(11, 17, 24, 0)"); 
            grd.addColorStop(0.3, "rgba(11, 17, 24, 0.95)"); 
            grd.addColorStop(1, "rgba(11, 17, 24, 1)"); 

            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.globalAlpha = 0.3;
            ctx.font = `${size * 0.8}px Arial`;
            ctx.shadowBlur = 30;
            ctx.shadowColor = "#fff";
            ctx.fillText("üöÄ", cx, cy);
            
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = 0;
        }
    }

    function closeMessage() {
        messageBox.classList.remove('show');
        if(!isGenerating && (player.x === goal.x && player.y === goal.y)) {
             flipAndReset(); 
        }
    }

    document.addEventListener('keydown', (e) => {
        if (isGenerating) return; 
        
        if (!solutionUsed && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            startTimer();
        }

        let nextX = player.x;
        let nextY = player.y;
        let currentCell = grid[index(player.x, player.y)];
        let moved = false;
        
        if (e.key === "ArrowUp" && !currentCell.walls[0]) { nextY--; moved = true; }
        else if (e.key === "ArrowRight" && !currentCell.walls[1]) { nextX++; moved = true; }
        else if (e.key === "ArrowDown" && !currentCell.walls[2]) { nextY++; moved = true; }
        else if (e.key === "ArrowLeft" && !currentCell.walls[3]) { nextX--; moved = true; }
        
        if (moved) {
            e.preventDefault(); 
            playSound('move'); 
            
            let prevCell = grid[index(player.x, player.y)];
            player.x = nextX;
            player.y = nextY;
            let newCell = grid[index(player.x, player.y)];

            if (solutionPath.length > 0) {
                let indexInSolution = solutionPath.indexOf(newCell);
                if (indexInSolution !== -1) {
                    solutionPath.splice(indexInSolution, 1);
                } else {
                    if (!mistakeCells.includes(newCell)) {
                        mistakeCells.push(newCell);
                        playSound('wall'); 
                    }
                    if (!mistakeCells.includes(prevCell)) mistakeCells.push(prevCell);
                }
            }

            draw();

            if(player.x === goal.x && player.y === goal.y) {
                stopTimer();
                playSound('win'); 
                const finalTime = Date.now() - startTime;
                
                if (solutionUsed) {
                     finalTimeDisplay.innerText = "ƒåas: " + formatTime(finalTime) + " (s pomoƒçjo)";
                     winTitle.innerText = "Labirint Re≈°en!";
                     winTitle.style.color = "#8da2b5"; 
                } else {
                     finalTimeDisplay.innerText = "Tvoj ƒças: " + formatTime(finalTime);
                     checkHighScore(finalTime);
                }
                
                setTimeout(() => messageBox.classList.add('show'), 100);
            }
        }
    });

    function toggleSolve() {
        if (isGenerating) return; 

        if (isSolutionShown) {
            solutionPath = []; 
            clearTimeout(solutionAnimationTimeout); 
            draw();
            solveBtn.innerText = "Poka≈æi re≈°itev ü§ñ";
            solveBtn.classList.remove('active');
            isSolutionShown = false;
        } else {
            stopTimer();
            solutionUsed = true;
            solveMazeAlgorithm();
            solveBtn.innerText = "Skrij re≈°itev üôà";
            solveBtn.classList.add('active');
            isSolutionShown = true;
        }
    }

    function solveMazeAlgorithm() {
        solutionPath = []; 
        mistakeCells = []; 
        draw();

        let visitedForSolver = new Set();
        let pathStack = [];
        let found = false;
        
        function dfs(c, r) {
            if (found) return;
            if (c < 0 || r < 0 || c >= cols || r >= rows) return;
            let idx = index(c, r);
            if (visitedForSolver.has(idx)) return;
            
            visitedForSolver.add(idx);
            pathStack.push(grid[idx]);

            if (c === goal.x && r === goal.y) {
                found = true;
                animateSolution(Array.from(pathStack)); 
                return;
            }

            let cell = grid[idx];
            if (!found && !cell.walls[0]) dfs(c, r - 1);
            if (!found && !cell.walls[1]) dfs(c + 1, r);
            if (!found && !cell.walls[2]) dfs(c, r + 1);
            if (!found && !cell.walls[3]) dfs(c - 1, r);
            if (!found) pathStack.pop();
        }
        dfs(player.x, player.y);
    }

    function animateSolution(fullPath) {
        let i = 0;
        if(fullPath.length > 0 && fullPath[0] === grid[index(player.x, player.y)]) {
            fullPath.shift();
        }
        function step() {
            if (i >= fullPath.length) return;
            solutionPath.push(fullPath[i]);
            draw();
            i++;
            solutionAnimationTimeout = setTimeout(step, 20); 
        }
        step();
    }

    initMaze();
</script>
</body>
</html>